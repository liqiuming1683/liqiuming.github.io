<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四轴飞行器学习笔记（二）：初识PID算法]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86PID%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[四轴飞行器中PID算法用于控制电机的转速，使其稳定在目标转速。 P：Proportion（比例），就是输入偏差乘以一个常数；I：Integral（积分），就是对输入偏差进行积分运算；D：Differential（微分），对输入偏差进行微分运算。 PID控制：将偏差的比例（P），积分（I），微分（D）通过线性组合构成控制量，用这一控制量对被控对象进行控制。 模拟PID控制原理PID控制是模拟控制系统中控制器最常用的控制规律。 常规的模拟PID控制系统原理框图如上所示，由模拟PID控制器和被控对象组成。 r(t)是给定值，y(t)是实际输出值，给定值与实际输出值构成控制偏差e(t)=r(t)-y(t)； e(t)作为PID控制的输入，u(t)作为PID控制器的输出和被控对象的输入。 所以模拟PID控制器的控制规律是： 其中：Kp —— 控制器的比例系数；Ti —— 是控制器的积分时间，也称积分系数；Td —— 是控制器的微分时间，也称微分系数。 比例环节：Kp*e(t)作用是对偏差瞬间做出反应，偏差一旦产生 ，控制器立即产生控制作用，使控制量向减少偏差的方向变化。控制作用的强弱取决于比例系数Kp；Kp越大，控制作用越强，则过渡过程越快，控制过程的静态偏差也就越小；但Kp越大，也越容易产生振荡，破坏系统的稳定性。 积分环节：Kp/Ti*∫e(t)dt作用是只要存在偏差，则它的控制作用就不断增加；只有在偏差e(t)=0时，积分部分才能是一个常数。积分部分虽会消除静态误差，但也会降低系统的响应速度，增加系统的超调量。Ti越大，积分的累积作用越弱，这时系统在过渡时不会产生振荡，可以减少超调量，提高系统稳定性；但是增大积分常数Ti会减慢静态误差的消除过程，消除偏差所需时间更长。 微分环节：KpTdde(t)/dt作用是根据偏差的变化趋势，预先给出适当修正，即阻止偏差的变化。偏差变化越快，微分控制器的输出越大。有助于减小超调量，克服振荡，是系统趋于稳定，特别对高阶系统非常有利，它加快了系统的跟踪速度。但微分对输入信号的噪声很敏感，因此对噪声较大的系统不用微分，或首先对输入信号进行滤波。Td越大，已知偏差变化的作用就越强。 数字PID控制将模拟PID控制引入到计算机中，用软件实现PID控制，即为数字PID控制。 数字式PID控制算法：位置式PID控制算法，增量式PID控制算法。 位置式PID控制算法由于计算机控制是一种采样控制，只能根据采样时刻的偏差计算控制量，因而以上积分部分和微分部分必须进行离散化后才能使用。 处理方法：以T为采样周期，k为采样序号，则离散采样时间kT对应着连续时间t，用矩阵法数值积分近似代替积分，用一阶后向差分近似代替微分： 上式中，e(kT)=ek 则离散的PID表达式为 以上控制算法式给出了全部控制量的大小，因此被称为全量式或位置式PID控制算法。 缺点： 由于全量输出，所以每次输出均与过去状态有关，计算时需要对ek进行累加，工作量大； 若计算机出现故障，其对应执行机构实际位置的输出uk会发生大幅度变化，进而引起执行机构实际位置大幅度变化。 而增量式PID控制算法可以避免这种现象。 增量式PID算法即控制器输出的是控制量的增量△uk。控制算法式如下： 如果计算机控制系统采用恒定的采样周期T，一旦确定A、B、C，只要使用前后三次测量的偏差值，就可以由上式求出控制量。增量式PID控制算法与位置式PID算法相比，计算量小的多，因此在实际中得到广泛的应用。 而位置式PID控制算法也可以通过增量式控制算法推出递推计算公式： 此即为目前在计算机控制中广泛应用的数字递推PID控制算法。 积分分离PID控制算法PID算法中引入积分环节，主要是为了消除静态误差，提高控制精度。但在过程的启动、结束或大幅度增减设定时，短时间系统输出有很大的偏差，会造成PID运算的积分运算。这会导致控制量超过执行机构可能允许的最大动作范围对应的极限控制量，引起系统较大的超调量，甚至引起系统较大的振荡。 因而引入积分分离PID控制算法：当被控量与设定值偏差较大时，取消积分作用；当被控量接近给定值时，引入积分控制。 具体实现步骤如下： 根据实际情况，人为设定阈值 ε&gt;0； 当 |e(k)|&gt;ε 时，采用PD控制，可避免产生过大的超调， 又使系统有较快的响应； 当 |e(k)|&lt;=ε 时，采用PID控制，以保证系统的控制精度。 积分分离控制算法可表示为 其中β为积分项的开关系数## 抗积分饱和PID控制算法 ##积分饱和现象：若系统存在一个方向的偏差，PID控制器的输出由于积分作用的不断累加而加大，从而导致执行机构达到极限位置Xmax。若控制器的输出u(k)继续增大，阈门开度不可能再增大，此时就称计算机输出控制量超出了正常运行范围，而进入了饱和区。一旦系统出现反向偏差，u(k)逐渐退出饱和区。进入饱和区愈深，退出时间愈长。在这段时间内，执行机构仍停留在极限位置而不能随偏差反向立即做出响应的改变，造成控制型能恶化。算法：在计算u(k)时，首先判断上一时刻的控制量u(k-1)是否已经超出限制范围。若u(k-1)&gt;umax，则只累加负偏差；若u(k-1)]]></content>
  </entry>
  <entry>
    <title><![CDATA[四轴飞行器学习笔记（一）：基本知识]]></title>
    <url>%2F2017%2F07%2F16%2F%E4%BB%8E%E9%9B%B6%E8%87%AA%E5%88%B6%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[暑假在家闲的慌，想要自己捣鼓个四轴飞行器，就先打基础吧，以后也好懂怎么给四轴升级硬件。 自制四轴的博客或帖子有很多（csdn，Arduino中文社区，21C电子网等等），较为深入的研究先不谈，比如PID算法，卡尔曼滤波等，先用现成的一些组件组装起来。 四轴飞行器结构和原理关于四轴飞行器的结构和原理直接参考了这篇人人小站上的博客。 结构形式旋翼对称分布在机体的前后、左右四个方向，四个旋翼处于同一高度平面，且四个旋翼的结构和半径都相同，四个电机对称的安装在飞行器的支架端，支架中间空间安放飞行控制计算机和外部设备。结构形式如图1.1所示。 工作原理四旋翼飞行器通过调节四个电机转速来改变旋翼转速，实现升力的变化，从而控制飞行器的姿态和位置。四旋翼飞行器是一种六自由度的垂直升降机，但只有四个输入力，同时却有六个状态输出，所以它又是一种欠驱动系统。 四旋翼飞行器的电机 1和电机 3逆时针旋转的同时，电机 2和电机 4顺时针旋转，因此当飞行器平衡飞行时，陀螺效应和空气动力扭矩效应均被抵消。在上图中，电机 1和电机 3作逆时针旋转，电机 2和电机 4作顺时针旋转，规定沿 x轴正方向运动称为向前运动，箭头在旋翼的运动平面上方表示此电机转速提高，在下方表示此电机转速下降。 垂直运动：同时增加四个电机的输出功率，旋翼转速增加使得总的拉力增大，当总拉力足以克服整机的重量时，四旋翼飞行器便离地垂直上升；反之，同时减小四个电机的输出功率，四旋翼飞行器则垂直下降，直至平衡落地，实现了沿 z轴的垂直运动。当外界扰动量为零时，在旋翼产生的升力等于飞行器的自重时，飞行器便保持悬停状态。 俯仰运动：在图（b）中，电机 1的转速上升，电机 3 的转速下降（改变量大小应相等），电机 2、电机 4 的转速保持不变。由于旋翼1 的升力上升，旋翼 3 的升力下降，产生的不平衡力矩使机身绕 y 轴旋转，同理，当电机 1 的转速下降，电机 3的转速上升，机身便绕y轴向另一个方向旋转，实现飞行器的俯仰运动。 滚转运动：与图 b 的原理相同，在图 c 中，改变电机 2和电机 4的转速，保持电机1和电机 3的转速不变，则可使机身绕 x 轴旋转（正向和反向），实现飞行器的滚转运动。 偏航运动：旋翼转动过程中由于空气阻力作用会形成与转动方向相反的反扭矩，为了克服反扭矩影响，可使四个旋翼中的两个正转，两个反转，且对角线上的各个旋翼转动方向相同。反扭矩的大小与旋翼转速有关，当四个电机转速相同时，四个旋翼产生的反扭矩相互平衡，四旋翼飞行器不发生转动；当四个电机转速不完全相同时，不平衡的反扭矩会引起四旋翼飞行器转动。在图 d中，当电机 1和电机 3 的转速上升，电机 2 和电机 4 的转速下降时，旋翼 1和旋翼3对机身的反扭矩大于旋翼2和旋翼4对机身的反扭矩，机身便在富余反扭矩的作用下绕 z轴转动，实现飞行器的偏航运动，转向与电机 1、电机3的转向相反。 前后运动：要想实现飞行器在水平面内前后、左右的运动，必须在水平面内对飞行器施加一定的力。在图 e中，增加电机 3转速，使拉力增大，相应减小电机 1转速，使拉力减小，同时保持其它两个电机转速不变，反扭矩仍然要保持平衡。按图 b的理论，飞行器首先发生一定程度的倾斜，从而使旋翼拉力产生水平分量，因此可以实现飞行器的前飞运动。向后飞行与向前飞行正好相反。（在图 b 图 c中，飞行器在产生俯仰、翻滚运动的同时也会产生沿 x、y轴的水平运动。） 倾向运动：在图 f 中，由于结构对称，所以倾向飞行的工作原理与前后运动完全一样。 四轴飞行器的组成及参数说明一般四轴飞行器的零部件及说明 无刷电机（4个） 电子调速器（简称电调，4个，常见有好盈、中特威、新西达等品牌） 螺旋桨（4个，需要2个正浆，2个反浆） 飞行控制板（常见有KK，MWC，QQ，NAZA，APM/PIX等品牌） 电池（11.1v航模动力电池） 遥控器（最低四通道遥控器） 机架（非必选） 充电器(尽量选择平衡充电器) 四轴零件之间的接线与简单说明 4个电调的正负极需要并联（红色连一起，黑色连1一起），并接到电池的正负极上； 电调3根黑色的电机控制线，连接电机； 电调有个BEC输出，用于输出5v的电压，给飞行控制板供电，和接收飞行控制板的控制信号； 遥控接收器连接在飞行控制器上，输出遥控信号，并同时从飞行控制板上得到5v供电； 基本原理与名词解释 遥控器通道：可以遥控器控制的动作路数，比如遥控器只能控制四轴上下飞，那么就是1个通道。但四轴在控制过程中需要控制的动作路数有：上下、左右、前后、旋转。所以最低得4通道遥控器。如果想以后玩航拍这些就需要更多通道的遥控器了。 遥控器油门：在四轴飞行器当中控制供电电流大小，电流大，电动机转得快，飞得高、力量大。反之同理。判断遥控器的油门很简单，遥控器2个摇杆当中，上下板动后不自动回到中间的那个就是油门摇杆。 日本手、美国手：遥控器上油门的位置在右边是日本手、在左边是美国手。 飞控：飞控板的作用就是通过飞控板上的陀螺仪，对四轴飞行状态进行快速调整（都是瞬间的事，不要妄想用人肉完成），如发现右边力量大，向左倾斜，那么就减弱右边电流输出，电机变慢，升力变小，自然就不再向左倾斜。 x模式和+模式： X模式要难飞一点，但动作更灵活。+模式要好飞一点，动作灵活差一点，所以适合初学者。特别注意，x模式和+模式的飞控安装是不同的（以kk飞控为例）。如果飞控板安装错误，会剧烈的晃动，根本无法飞。 电调： 电调的作用就是将飞控板的控制信号，转变为电流的大小，以控制电机的转速；飞控板无法直接承受电机正常工作时的大电流（每个平均3A左右），且其本身也没有驱动无刷电机的功能。电调还充当变压器作用（11.1V → 5V 为飞控板和遥控接收器供电） 电调型号:都会标上多少A，这个数字是电调能够提供的电流。大电流的电调可以兼容用在小电流的地方，小电流电调不能超标使用。 常见新西达2212加1045浆最大电机电流有可能达到了5a，为了保险起见，建议这样配置用30a 或 40a电调（大家用20a电调的也多），说买大一点，以后还可以用到其他地方去。 无刷电机： 无刷是四轴的主流（相较于有刷电机），它力气大，耐用。 无刷电机型号：由四位数字组成，比如2212电机，2018电机等。前面2位是电机转子的直径，后面2位是电机转子的高度。 电机kV值：kV是外加1V电压对应的每分钟空转转速。比如：1000kv电机，外加1v电压，电机空转时每分钟转1000转，外加2v电压，电机空转就2000转了。 螺旋桨： 螺旋桨型号：由四位数字组成，比如1045,7040等，前面2位代表桨的直径（单位：英寸 1英寸=254毫米）后面2位是桨的角度。 正反桨：四轴飞行为了抵消螺旋桨的自旋，相隔的桨旋转方向是不一样的，所以需要正反桨。正反桨的风都向下吹。适合顺时针旋转的叫正浆、适合逆时针旋转的是反浆。安装的时候，一定记得无论正反桨，有字的一面是向上的（桨叶圆润的一面要和电机旋转方向一致）。 电机与螺旋桨的搭配： 建议采用常见的配置，例如：常用1000kv电机，配10寸左右的桨。 螺旋桨越大，升力就越大，但对应需要更大的力量来驱动； 螺旋桨转速越高，升力越大； 电机的kv越小，转动力量就越大； 综上所述，大螺旋桨就需要用低kv电机，小螺旋桨就需要高kv电机（因为需要用转速来弥补升力不足） 如果高kv带大桨，力量不够，那么就很困难，实际还是低速运转，电机和电调很容易烧掉。如果低kv带小桨，完全没有问题，但升力不够，可能造成无法起飞。 机型与电机、桨的关系： 桨越大对飞机所产生的反扭力越大，所以桨的大小与机的翼展大小有着一定关系，但桨与电机也有着上面所讲的关系。 例如用1060桨，机的翼展就得要在80CM以上为合适，不然的话机就容易造成反扭；又如用8*6的桨翼展就得在60以上。 飞控怎么选？有名的开源飞控：KK，QQ，匿名，MultiWii/MWC，APM/PIX等。 KK、QQ飞控功能较少，只有基本的四轴飞行功能，甚至不支持GPS； 匿名飞控是国内新出现的飞控，功能比以上两个要多，价格也要贵很多； MultiWii/MWC飞控是基于arduino的，支持GPS，能路线规划，在线调试； APM也是基于arduino的，功能更为齐全，硬件也更为复杂，飞控中有两块单片机，分别执行不同功能。APM已将arduino的性能开发到极限，于是有了升级版PIX，从arduino转到了STM32，处理速度提升了10倍，同样用了两块不同型号的STM32协同运作，是目前已知的最好的开源飞控。 电池和充电器 电池型号参数： mAh：电池容量，比如1000mAh电池，如果以1000mA放电，可持续放电1小时； s：锂电池节数，锂电池1节标准电压为3.7v，那么2s电池，就是代表有2个3.7v电池在里面，电压为7.4v； c：电池放电能力，比如1000mAh电池，标准为5c，那么可用5x1000mAh的电流强度放电。 怎样配电池：容量越大，c越高，s越多，电池越重； 基本原理是用大桨，因为整体搭配下来功率高，自身升力大，为了保证可玩时间，可选高容量，高c，3s以上电池。最低建议1500mah，20c，3s。 小四轴，因为自身升力有限，整体功率也不高，就可以考虑小容量，小c，3s以下电池。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Arduino开源机械臂]]></title>
    <url>%2F2017%2F07%2F11%2FArduino%E5%BC%80%E6%BA%90%E6%9C%BA%E6%A2%B0%E8%87%82%2F</url>
    <content type="text"><![CDATA[项目说明整体目标是基于Arduino设计能用手机控制的机械臂。 项目可拆分为下面四部分进行： 参考ABB IRB760工业码垛机械臂，且为降低制作成本，设计不需利用3D打印技术而只是用亚克力板和棒即可制作的桌面级机械臂； 测试Arduino控制四个舵机的代码，通过舵机实现对机械臂的控制； 通过手机控制可选的无线通信方案有：BLE，WiFi等，这里先选择BLE，选用HC-05蓝牙芯片，用手机对Arduino发送指令控制舵机； 组装机械臂调试。 ProcessPart1：机械臂设计ABB IRB760工业码垛机械臂即如下图所示 据此自行设计的机械臂已上传至MOST3D，效果如下图 SolidWorks文件已上传至百度文档可以下载查看 part2：舵机控制测试Arduino控制舵机的代码，通过舵机实现对机械臂的控制； 测试时用电位器调节舵机的旋转位置； /* * date: 2017/07/06 * author: liqiuming * requirement statement: * firstly, test servo SG90 in mega2560 * then use Potentiometer as a input source to control servo MG995 */ #include &lt;Servo.h&gt; Servo MG995; int posServo = 0;//position of servo int pinPotentiometer = A1; void setup() { // put your setup code here, to run once: MG995.attach(2); pinMode(pinPotentiometer,INPUT); } void loop() { // put your main code here, to run repeatedly: int val = analogRead(pinPotentiometer); int valForServo = map(val,0,1024,0,180); MG995.write(valForServo); } Part3：蓝牙遥控测试HC-05蓝牙芯片：使用的Arduino开发板型号是mega2560HC-05与mega2560的连接方式是： 将HC-05的TX引脚与mega2560RX引脚（0）相连，HC-05的RX引脚置空，因为不需要把数据从开发板发送到手机； 将HC-05接入电源，用手机连接蓝牙，配对密码为1234； 用手机发送指令控制舵机转动角度测试：手机每发送“0”时，舵机的角度增加5度；每发送“1”时，舵机角度减小5度。 /* * date:2017/07/07 * author：liqiuming * requirement statement: * test BLE module HC-05 with cellphone * meanwhile we need test 4 servos at the same time */ #include &lt;Servo.h&gt; // 4 Servos are used, 3 are MG995 and 1 is SG90 Servo MG995A; Servo MG995B; Servo MG995C; Servo SG90D; //initial positions of all Servo are 0 degree int posServoA= 0; int posServoB= 0; int posServoC= 0; int posServoD= 0; void setup() { // put your setup code here, to run once: Serial.begin(9600); MG995A.attach(2); MG995B.attach(3); MG995C.attach(4); SG90D.attach(5); } void loop() { // put your main code here, to run repeatedly: if(Serial.available()&gt;0){ char ch = Serial.read(); switch(ch){ case &apos;0&apos;: angleUpA();//发送“0”，MG995A角度增加5度； break; case &apos;1&apos;: angleDownA();//发送“1”，MG995A角度减少5度； break; case &apos;2&apos;: angleUpB();//发送“2”，MG995B角度增加5度； break; case &apos;3&apos;: angleDownB();//发送“3”，MG995B角度减少5度； break; case &apos;4&apos;: angleUpC();//发送“4”，MG995C角度增加5度； break; case &apos;5&apos;: angleDownC();//发送“5”，MG995C角度减少5度； break; case &apos;6&apos;: angleUpD();//发送“6”，MG995D角度增加5度； break; case &apos;7&apos;: angleDownD();//发送“7”，MG995D角度减少5度； break; } } } //below are the functions to increase or decrease each Servo&apos;s degrees //functions to control MG995A void angleUpA(){ posServoA += 5; MG995A.write(posServoA); Serial.print(&quot;MG995A&apos;s angle(°) is &quot;); Serial.println(posServoA); } void angleDownA(){ posServoA -= 5; MG995A.write(posServoA); Serial.print(&quot;MG995A&apos;s angle(°) is &quot;); Serial.println(posServoA); } //functions to control MG995B void angleUpB(){ posServoB += 5; MG995B.write(posServoB); Serial.print(&quot;MG995B&apos;s angle(°) is &quot;); Serial.println(posServoB); } void angleDownB(){ posServoB -= 5; MG995B.write(posServoB); Serial.print(&quot;MG995B&apos;s angle(°) is &quot;); Serial.println(posServoB); } //functions to control MG995C void angleUpC(){ posServoC += 5; MG995C.write(posServoC); Serial.print(&quot;MG995C&apos;s angle(°) is &quot;); Serial.println(posServoC); } void angleDownC(){ posServoC -= 5; MG995C.write(posServoC); Serial.print(&quot;MG995C&apos;s angle(°) is &quot;); Serial.println(posServoC); } //functions to control SG90D void angleUpD(){ posServoD += 5; SG90D.write(posServoD); Serial.print(&quot;SG90D&apos;s angle(°) is &quot;); Serial.println(posServoD); } void angleDownD(){ posServoD -= 5; SG90D.write(posServoD); Serial.print(&quot;SG90D&apos;s angle(°) is &quot;); Serial.println(posServoD); } Part4：组装调试 组装进行机械臂调试]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于Arduino的PSP采集系统同步触发装置设计]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%9F%BA%E4%BA%8EArduino%E7%9A%84%E8%BD%AC%E5%AD%90%E5%8E%8B%E6%95%8F%E8%8D%A7%E5%85%89%E5%9B%BE%E5%83%8F%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%8C%E6%AD%A5%E8%A7%A6%E5%8F%91%E8%A3%85%E7%BD%AE%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[写在前面2017年6月我本科毕业，毕业设计花了前前后后4个多月的样子，中途还更换过实验方案。由于觉得毕业内容很有原创性，且相较于我的专业比较有突破性，就想把毕设内容总结一下贴出来。 本人是飞行器动力工程专业，但毕设做的偏向电子方面，希望电子方面的大佬可以给点意见。 我会尽量简洁易懂地将其叙述出来。 背景介绍 什么是PSP？ PSP是Pressure Sensitive Paint的缩写，荧光氧猝灭压敏涂料。其受激发光源激发，会跟随环境压力大小而发出强度不同的荧光。激发光源通常可以是紫外光或激光等。而航空发动机转子叶片压力的测量可应用此项技术，将其涂在叶片表面，并通过拍摄叶片荧光图像可以获得表面压力分布数据。相较于传统在叶片表面开测压孔等机械破坏的测压方式，大大简化测压实验准备工作。 PSP采集系统有什么需求？ 最终目标是采集转子叶片表面的荧光图像，但受限于相机的分辨率，我们只能将相机取景范围限制在一个叶片的大小，且图像采集时转子保持旋转状态，因此为达目标作如下说明： 相机对准转子风扇的一个特定相位，需要在涂有压敏涂料的叶片旋转至该相位时，将其图像捕捉； 在行业里对于PSP图像采集一般有两种方式：高速图像采集法和相位锁定法。我也是针对这两种方法设计的采集系统同步触发装置。 高速图像采集法：激发光源对叶片表面PSP持续激发出荧光，在该叶片旋转至相机取景范围时，触发相机快门进行拍摄。 相位锁定法：实验处于完全暗光条件下，整个测量过程中相机快门保持常开的状态，在涂有PSP的叶片进入相机取景范围时触发激发光源点亮。 采集系统组成说明基于需求，做出的设计方案如下图所示： 计算机作用是接收相机输入的图像以及烧写程序进同步触发器； 激发光源是紫外光，是四组UVLED串组成的阵列，每组需30-40V/700mA电源； CCD相机型号日本滨松（HAMAMATSU）公司ORCA-R2高灵敏度制冷型CCD相机； 转子风扇独立供电不需控制，最高转速3000rpm； 光电传感器用于反应叶片的相位，其自身会发出红外光，当该束红外光反射并被接收到时，输出高电平信号。我们在转子轴部分较偏心处贴有反光纸，其相位处于当涂有PSP的叶片处于相机取景范围正中时，红外光会被反光纸反射。即光电传感器的作用即是反应叶片的相位。 同步触发器的设计基于Arduino平台。 装置设计方案需求： 在高速图像采集法下，采集系统内的相机需要拍摄下每一转同一个涂有PSP叶片的图像，并且为方便后期图像处理，需要拍摄的图像之间相位偏差小。需要设计的采集系统同步触发装置需要控制激发光源，相机快门以及接受光电传感器信号。 光电传感器信号的输入 光电传感器是反射式的，供电电压10V，输出TTL信号（接收到反光时输出高电平，没有反光时输出低电平），其高电平电压经测量得为9V左右。在将信号给到Arduino时，首先利用电位计（10kΩ）对其进行降压处理，降为高电平4.5V后信号输给Arduino。 相机快门控制 实验室所用的CCD相机自身带有外触发模式，当有5V高电平信号输入，即可触发相机打开快门拍摄。 激发光源控制 实验室激发光源是紫外光，是四组UVLED串组成的阵列，每组需30-40V/700mA电源，在高速图像采集法下不需要控制，而在相位锁定法下需要控制其通断。由于Arduino的信号电压无法驱动光源工作，因有以下设计：紫外灯有其自己的供电电源，且用到固态继电器使得Arduino可以间接控制紫外灯的点亮和熄灭。 装置响应频率测试由于装置目标工作环境是在转速3000rpm或更高，因此其本身的响应频率是影响实验结果的直接因素。主要测试一下几部分：光源的响应特性，固态继电器的响应频率。 固态继电器响应频率测试 测试原理： 固态继电器共有四个引脚，其中1,2脚接入光源的供电回路，3,4脚接入Arduino控制回路，控制逻辑是在3脚置高时1,2脚之间导通。 Arduino输出固定频率信号到固态继电器3脚（4脚接地），再接收1脚的高电平信号（2脚置高），将该信号转换成频率并在串口显示。如果输出信号频率与输入信号频率相等，则再不断调高输入信号的频率，直至二者不等或者前者不稳定时，则说明此即为固态继电器的响应上限。最终测试得到上限响应频率1kHz，满足实验需求。 光源的响应特性测试 测试原理：通过检测光源频闪时的光强大小及变化，来检验其在高频下的响应特性。测试时将紫外光源照向贴有荧光纸的平整表面，并利用PMT对荧光纸表面单点测量其荧光强度。PMT的响应时间为纳秒级，十分灵敏且噪声小。在PMT前设有通过波长为625±25nm的滤波片，可以将反射回光信号中的杂色光滤掉。 PMT:Photo Multiplier Tube，光电倍增管，能在低能级光度学和光谱学方面测量波长200~1200纳米的极微弱辐射功率。 测试结果如图：选择了四个频率下测试：25Hz、33.3Hz、50Hz以及250Hz，所得光强-时间图像。 可以看出，即便最高在250Hz的频率下，紫外光源依旧能够保持频率地点亮和熄灭。实验风扇最高转速3000rpm，即对应频率50Hz，因而频率上能够满足实验的需求。 装置制作高速图像采集法下原理图及代码 为锁相更为准确，采用两个反射式光电传感器; 逻辑是将两个传感器紧靠放置，在第一个传感器信号置高，判断第二个传感器信号是否置高，若为高则判断叶片进入相机取景范围，此时即可触发相机快门进行拍摄。 添加了一块LCD1602屏幕用来显示风扇转速。 /* * 需求说明：相位锁定法下同步触发装置设计 * Arduino输出高电平，实现对紫外光源的控制；风扇独立运转，不需控制。 * 同时加入LCD1602显示屏对风扇转速进行显示；串口显示旋转的圈数。 * 反射式的反光纸尺寸可以较大，使得其置高的时间稍超前于反射式。 * 整个装置的引脚设置如下： * 12,11,10,9,8,7——LCD1602 * 6——反射式传感器1 * 5——反射式传感器2 * 1——相机输出引脚 */ //引入LiquidCrystal头文件（内含LCD显示相关函数） #include &lt;LiquidCrystal.h&gt; //构造一个LiquidCrystal的类成员，使用数字I/O：12,11,5,4,3,2 LiquidCrystal lcd(12,11,10,9,8,7); int pinSensorRe1 = 6;//反射式光电传感器1引脚号 int pinSensorRe2 = 5;//反射式光电传感器2引脚号 int pinCamera = 1;//输出给CCD相机信号的引脚号 int cnt = 0;//用于给信号计数 long lastRotateTime = 0;//上一转时已经经过的机器时间 int lastState1 = LOW;//上一转反射式传感器1的状态值 void setup() { // put your setup code here, to run once: // 引脚设置 pinMode(pinSensorRe1, INPUT);//反射式光电传感器1信号设为输出 pinMode(pinSensorRe2, INPUT);//反射式光电传感器2信号设为输出 pinMode(pinCamera, INPUT);//CCD相机信号设置为输出 // 液晶显示“SYNCHRONOUS TRIGGER” lcd.begin(16,2);//初始化LCD1602 lcd.setCursor(0,0); lcd.print(&quot;SYNCHRONOUS&quot;); lcd.setCursor(0,1); lcd.print(&quot;Trigger&quot;);//液晶显示&quot;SYNCHRONOUS TRIGGER&quot; delay(2000);//延时2000ms lcd.clear();//清屏 lcd.setCursor(0,0); lcd(&quot;RotateSpeed(rpm)&quot;);//液晶显示&quot;RotateSpeed(rpm) &quot; Serial.begin(9600); } void loop() { // put your main code here, to run repeatedly: int rotateSpeed;//风扇的旋转速度 float Time;//旋转一圈所需的时间 int valRe1 = digitalRead(pinSensorRe1);//valRe1存储反射式传感器1的状态值 int valRe2 = digitalRead(pinSensorRe2);//valRe2存储反射式传感器2的状态值 //两个传感器均置高，则说明指定叶片进入相机取景范围 if(valRe1 == HIGH){ if(lastState1 == LOW){ Time = millis() - lastRotateTime; lastRotateTime = millis(); rotateSpeed = 16.67*Time;//将转速求出并单位换算成rpm lcdDisplay(rotateSpeed);//调用lcdDisplay函数 } if(valRe2 == HIGH){ //后期根据拍摄情况可能会对延迟进行调教设置 //delay(50);//或可能是delayMicrosenconds()函数 digitalWrite(pinCamera, HIGH);//同时输出一个高电平信号给相机 cnt++;//次数+1 } }else{ digitalWrite(pinCamera, LOW); } lastState1 = valRe1;//这一转的传感器1状态值是下一转的lastState1值 Serial.println(cnt);//串口显示信号输出的次数 } //自定义LCD显示函数，用于显示转速 void lcdDisplay(int rotateSpeed) { lcd.setCursor(0,1);//设置液晶开始显示的位置在第二行第一个数位 lcd.print(rotateSpeed); } 拍摄结果： 选择了四个转速进行了图像采集，分别是1000rpm、1500rpm、2000rpm和2500rpm。每个转速下通过改变相机的快门时间获得指定叶片固定相位的一组照片，且每组均连续采集100张，取出第1,21,41,61,81张图像进行分析比较。为使图像更加清晰，这些照片已经经过亮度的调节。 风扇转速1000rpm条件下，更改相机快门时间得到的图像如下：快门时间90us快门时间100us快门时间120us 风扇转速1500rpm条件下，更改相机快门时间得到的图像如下：快门时间50us快门时间80us快门时间100us 风扇转速2000rpm条件下，拍摄得的图像如下：快门时间80us 风扇转速2500rpm条件下，拍摄得的图像如下：快门时间50us 连续播放100张照片的视频已将上传至Youtube 实验结果分析：观察特定叶片指定相位下拍摄得到的图像可以看出，虽然有快门时间短导致进光量不够，使得图像亮度比较暗，清晰度不高的现象，但仍可以看出此种方法下照片之间的偏移小，能够满足精度要求，说明此种方法能够准确地锁住相位，证明本文设计的同步触发装置采用高速图像采集法时满足要求 相位锁定法下原理图及代码 /* * 需求说明：相位锁定法下同步触发装置设计 * Arduino输出高电平，实现对紫外光源的控制；风扇独立运转，不需控制。 * 同时加入LCD1602显示屏对风扇转速进行显示；串口显示旋转的圈数。 * 反射式的反光纸尺寸可以较大，使得其置高的时间稍超前于反射式。 * 整个装置的引脚设置如下： * 12,11,10,9,8,7——LCD1602 * 6——反射式传感器1 * 5——反射式传感器2 * 4——对射式传感器 * 3——紫外光源控制引脚1 * 2——紫外光源控制引脚2 * 1——相机输出引脚 */ #include &lt;LiquidCrystal.h&gt;//引入LiquidCrystal头文件（内含LCD显示相关函数） //构造一个LiquidCrystal的类成员，使用数字I/O：12,11,5,4,3,2 LiquidCrystal lcd(12,11,10,9,8,7); int pinSensorRe1 = 6;//反射式光电传感器1引脚号 int pinSensorRe2 = 5;//反射式光电传感器2引脚号 int pinSensorOp = 4;//对射式光电传感器引脚号 int pinUVlight1 = 3;//紫外光源控制信号1引脚号 int pinUVlight2 = 2;//紫外光源控制信号2引脚号 int pinCamera = 1;//输出给CCD相机信号的引脚号 int cnt = 0;//用于给信号计数 long lastRotateTime = 0;//上一转时已经经过的机器时间 int lastState1 = LOW;//上一转反射式传感器1的状态值 void setup() { // put your setup code here, to run once: // 引脚设置 pinMode(pinSensorRe1, INPUT);//反射式光电传感器1信号设为输出 pinMode(pinSensorRe2, INPUT);//反射式光电传感器2信号设为输出 pinMode(pinSensorOp, INPUT);//对射式光电传感器信号设为输出 pinMode(pinUVlight1, OUTPUT);//UV光源控制信号1设为输出 pinMode(pinUVlight2, OUTPUT);//UV光源控制信号2设为输出 pinMode(pinCamera, INPUT);//CCD相机信号设置为输出 // 液晶显示“SYNCHRONOUS TRIGGER” lcd.begin(16,2);//初始化LCD1602 lcd.setCursor(0,0); lcd.print(&quot;SYNCHRONOUS&quot;); lcd.setCursor(0,1); lcd.print(&quot;Trigger&quot;);//液晶显示&quot;SYNCHRONOUS TRIGGER&quot; delay(2000);//延时2000ms lcd.clear();//清屏 lcd.setCursor(0,0); lcd(&quot;RotateSpeed(rpm)&quot;);//液晶显示&quot;RotateSpeed(rpm) &quot; Serial.begin(9600); } void loop() { // put your main code here, to run repeatedly: int rotateSpeed;//风扇的旋转速度 float Time;//旋转一圈所需的时间 int valRe1 = digitalRead(pinSensorRe1);//valRe1存储反射式传感器1的状态值 int valRe2 = digitalRead(pinSensorRe2);//valRe2存储反射式传感器2的状态值 //两个传感器均置高，则说明指定叶片进入相机取景范围 if(valRe1 == HIGH){ if(lastState1 == LOW){ Time = millis() - lastRotateTime; lastRotateTime = millis(); rotateSpeed = 16.67*Time;//将转速求出并单位换算成rpm lcdDisplay(rotateSpeed);//调用lcdDisplay函数 } if(valRe2 == HIGH){ //后期根据拍摄情况可能会对延迟进行调教设置 //delay(50);//或可能是delayMicrosenconds()函数 digitalWrite(pinUVlight1, HIGH);//传感器输出为HIGH时，UV光源引脚1置高 digitalWrite(pinUVlight2, HIGH);//传感器输出为HIGH时，UV光源引脚2置高 digitalWrite(pinCamera, HIGH);//同时输出一个高电平信号给相机 cnt++;//次数+1 } }else{ digitalWrite(pinUVlight1, LOW); digitalWrite(pinUVlight2, LOW); digitalWrite(pinCamera, LOW); } lastState1 = valRe1;//这一转的传感器1状态值是下一转的lastState1值 Serial.println(cnt);//串口显示信号输出的次数 } //自定义LCD显示函数，用于显示转速 void lcdDisplay(int rotateSpeed) { lcd.setCursor(0,1);//设置液晶开始显示的位置在第二行第一个数位 lcd.print(rotateSpeed);//显示实时转速 } 拍摄结果： 结果分析： 首先由于图像在相机底片上叠加作用，亮度明显偏高使得最终图片过曝，因而需要调低紫外光源的亮度； 其次，虽然已经将风扇除贴有反光纸的叶片外均涂上了黑色油漆，消除了漫反射的影响，但仍然有部分存在镜面反射的作用，可以明显看到转子中心轴的部分也反射了光进入相机快门； 可以明显观察到所得图像的拖影比较严重。虽然章节2中测试得到的光源能够最高在250Hz的频率下保持较好的特性，但需要注意的是该结果是在测试条件是在光源占空比为0.5时获得。而实际测量在1000rpm下，即旋转一圈60ms，根据高速图像采集法的校验经验，快门至多150us才能使得图像不产生拖影，光源同理，因而光源需要占空比低至0.0025时，清晰无拖影的叶片图像才能在相机底片上成像。而在如此低占空比下光源无法被点亮，此原因还尚未可知。因而为点亮光源而提高占空比，这是使得图像产生拖影的主要原因，因此后期如果采用相位锁定法则需要更换光源。 外壳制作外壳效果如图 实物如图： 装置说明： 光源电源可调，范围0-40V/5A可调，可以调节其上的电位器改变电压来调节紫外光源的亮度； 本装置设有2个反射式传感器接口，其中2号接口回路中接入了一个电位器，为以后有更高精度传感器但供电电压低于DC24V预留，可以调节电位器使供给传感器的电压降低； 装置留有1个对射式光电传感器接口，虽然对射式传感器的响应频率要求更高，但其在精度允许范围内锁相更为准确，因此为以后有更高精度的对射式传感器预留； 装置设有2个光源接口，用以给一个UVLED灯头供电，分别控制其2组UVLED串列； 装置留给相机引脚为两个导线，分别是信号和接地，导线颜色分别是红色和黑色。 总结 由于图像的清晰度直接与相机的快门时间和风扇转速相关，因此进一步开发利用了光电传感器的功能对风扇转速进行测量，并加入了LCD屏幕显示转速，对于实验数据记录便捷性大有裨益； 经电位器降压后的传感器输出信号出现噪声，使得无法正确地触发相机和光源，因而利用74LS14施密特触发器对其输出信号进行整形，减小信号噪声，减弱了其对拍摄的影响； 鉴于对射式传感器在其响应频率范围内的锁相精度更高，因而尝试使用对射式传感器替代反射式传感器，但实际发现对射式传感器响应频率的要求是反射式传感器的7倍，只适合在低转速情形下实验，高转速实验条件下发展空间不大，因此暂时放弃进一步探究此种方法； 为提高锁相精度，本文又尝试使用两个反射式传感器组合的方法对叶片进行锁相，发现这种方法下拍摄的相位锁定能力和图像清晰度最佳； 两个反射式传感器结合的方案直接移置到相位锁定法下进行拍摄，得到的结果并不令人满意，初步判断是由于光源的特性不满足要求，即光源在低占空比下特性差，高占空比下又使得拍摄时图像在相机底片重叠产生拖影。因此后期需要更换光源。]]></content>
  </entry>
  <entry>
    <title><![CDATA[李秋铭的测试文章]]></title>
    <url>%2F2017%2F07%2F10%2F%E6%9D%8E%E7%A7%8B%E9%93%AD%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[这是一篇测试文章，欢迎关注作者博客[1]：http：//liqiuming1683.github.io/]]></content>
  </entry>
</search>